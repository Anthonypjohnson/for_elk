# Hayabusa CSV Parser
# SOF-ELK style: 6000-6999 range for log-type-specific parsers
# CRITICAL: EventID and RuleTitle MUST remain as strings (keyword type in ES)

filter {
  if [type] == "hayabusa-csv" {
    # Parse CSV with Hayabusa column structure
    csv {
      separator => ","
      columns => [
        "Timestamp",
        "Computer",
        "Channel",
        "EventID",
        "Level",
        "RecordID",
        "RuleTitle",
        "Details",
        "ExtraFieldInfo",
        "RuleFile",
        "EvtxFile",
        "RuleID",
        "MitreTactics",
        "MitreTags",
        "OtherTags"
      ]
      skip_header => true
      skip_empty_columns => true
    }

    # Parse timestamp - Hayabusa format: "yyyy-MM-dd HH:mm:ss.SSS +00:00"
    date {
      match => [
        "Timestamp",
        "yyyy-MM-dd HH:mm:ss.SSS ZZ",
        "yyyy-MM-dd HH:mm:ss.SSS",
        "ISO8601"
      ]
      target => "@timestamp"
      timezone => "UTC"
      tag_on_failure => ["_dateparsefailure"]
    }

    # Type conversions
    # CRITICAL: EventID must stay as string (keyword in Elasticsearch)
    # CRITICAL: RuleTitle must stay as string (keyword in Elasticsearch)
    mutate {
      convert => {
        "RecordID" => "integer"
      }
    }

    # Strip whitespace from string fields
    mutate {
      strip => [
        "Computer",
        "Channel",
        "EventID",
        "Level",
        "RuleTitle",
        "RuleFile",
        "EvtxFile",
        "RuleID"
      ]
    }

    # Split MITRE fields if they contain multiple values (comma-separated)
    if [MitreTactics] and [MitreTactics] != "" {
      mutate {
        split => { "MitreTactics" => "," }
        strip => ["MitreTactics"]
      }
    }

    if [MitreTags] and [MitreTags] != "" {
      mutate {
        split => { "MitreTags" => "," }
        strip => ["MitreTags"]
      }
    }

    if [OtherTags] and [OtherTags] != "" {
      mutate {
        split => { "OtherTags" => "," }
        strip => ["OtherTags"]
      }
    }

    # Create display-friendly fields for Kibana
    mutate {
      add_field => {
        "event_description" => "%{Details}"
        "extra_info" => "%{ExtraFieldInfo}"
      }
    }

    # Remove the raw message field (no longer needed after CSV parsing)
    mutate {
      remove_field => ["message", "host"]
    }

    # Tag parse failures for debugging
    if "_csvparsefailure" in [tags] {
      mutate {
        add_tag => ["parse_error", "hayabusa_csv_parse_error"]
        add_field => {
          "parse_error_type" => "csv_parsing_failed"
        }
      }
    }

    # Add successfully parsed tag
    if "_csvparsefailure" not in [tags] {
      mutate {
        add_tag => ["successfully_parsed"]
      }
    }
  }
}
